
// TODO: Currently unused after forking @fisch0920/drizzle-zod.
export function makeNullablePropsOptional<Schema extends z.AnyZodObject>(
  schema: Schema
): z.ZodObject<{
  [key in keyof Schema['shape']]: Schema['shape'][key] extends z.ZodNullable<
    infer T
  >
    ? z.ZodOptional<T>
    : Schema['shape'][key]
}> {
  const entries = Object.entries(schema.shape)
  const newProps: any = {}

  for (const [key, value] of entries) {
    newProps[key] =
      value instanceof z.ZodNullable ? value.unwrap().optional() : value
    return newProps
  }

  return z.object(newProps) as any
}

export type ColumnType =
  // string
  | 'text'
  | 'varchar'
  | 'timestamp'
  | 'stripeId'
  | 'projectId'
  | 'deploymentId'
  | 'cuid'
  // boolean
  | 'boolean'
  // number
  | 'integer'
  | 'smallint'
  | 'bigint'
  // json
  | 'json'
  | 'jsonb'

export type ColumnTypeToTSType<T extends ColumnType> = T extends
  | 'text'
  | 'varchar'
  | 'timestamp'
  | 'cuid'
  | 'stripeId'
  | 'projectId'
  | 'deploymentId'
  ? string
  : T extends 'boolean'
    ? boolean
    : T extends 'integer' | 'smallint' | 'bigint'
      ? number
      : never

/**
 * @see https://github.com/drizzle-team/@fisch0920/drizzle-orm/issues/2745
 */
function optional<
  T extends ColumnType,
  InferredType extends
    | string
    | boolean
    | number
    | object = ColumnTypeToTSType<T>
>(dataType: T) {
  return customType<{
    data: InferredType | undefined
    driverData: InferredType | null
    config: T extends 'stripeId'
      ? {
          length: number
        }
      : never
  }>({
    dataType() {
      if (dataType === 'stripeId') {
        return 'varchar({ length: 255 })'
      }

      if (dataType === 'cuid') {
        return 'varchar({ length: 24 })'
      }

      if (dataType === 'projectId') {
        return 'varchar({ length: 130 })'
      }

      if (dataType === 'deploymentId') {
        return 'varchar({ length: 160 })'
      }

      if (dataType === 'timestamp') {
        return 'timestamp({ mode: "string" })'
      }

      return dataType
    },
    fromDriver: (v) => v ?? undefined,
    toDriver: (v) => v ?? null
  })
}

export const optionalText = optional('text')
export const optionalTimestamp = optional('timestamp')
export const optionalBoolean = optional('boolean')
export const optionalVarchar = optional('varchar')
export const optionalCuid = optional('cuid')
export const optionalStripeId = optional('stripeId')
export const optionalProjectId = optional('projectId')
export const optionalDeploymentId = optional('deploymentId')

// ---


type MaybePromise<T> = Promise<T> | T;
type RequestTypes = {
    body?: ZodRequestBody;
    params?: ZodType;
    query?: ZodType;
    cookies?: ZodType;
    headers?: ZodType | ZodType[];
};
type InputTypeBase<R extends RouteConfig, Part extends string, Type extends keyof ValidationTargets> = R['request'] extends RequestTypes ? RequestPart<R, Part> extends ZodType ? {
    in: {
        [K in Type]: HasUndefined<ValidationTargets[K]> extends true ? {
            [K2 in keyof z.input<RequestPart<R, Part>>]?: z.input<RequestPart<R, Part>>[K2];
        } : {
            [K2 in keyof z.input<RequestPart<R, Part>>]: z.input<RequestPart<R, Part>>[K2];
        };
    };
    out: {
        [K in Type]: z.output<RequestPart<R, Part>>;
    };
} : {} : {};

type InputTypeParam<R extends RouteConfig> = InputTypeBase<R, 'params', 'param'>;
type InputTypeQuery<R extends RouteConfig> = InputTypeBase<R, 'query', 'query'>;
type InputTypeHeader<R extends RouteConfig> = InputTypeBase<R, 'headers', 'header'>;
type InputTypeCookie<R extends RouteConfig> = InputTypeBase<R, 'cookies', 'cookie'>;

type o: <R extends RouteConfig, I extends Input = InputTypeParam<R> & InputTypeQuery<R> & InputTypeHeader<R> & InputTypeCookie<R> & InputTypeForm<R> & InputTypeJson<R>, P extends string = ConvertPathType<R["path"]>>({ middleware: routeMiddleware, hide, ...route }: R, handler: Handler<R["middleware"] extends MiddlewareHandler[] | MiddlewareHandler ? RouteMiddlewareParam<R>["env"] & E : E, P, I, R extends {
    responses: {
        [statusCode: number]: {
            content: {
                [mediaType: string]: ZodMediaTypeObject;
            };
        };
    };
} ? MaybePromise<RouteConfigToTypedResponse<R>> : MaybePromise<RouteConfigToTypedResponse<R>> | MaybePromise<Response>>) => OpenAPIHono<E, S & ToSchema<R["method"], MergePath<BasePath, P>, I, RouteConfigToTypedResponse<R>>, BasePath>;


// ---

import type { SetOptional, SetRequired, Simplify } from 'type-fest'
import type { AnyZodObject } from 'zod'
import { createRoute, type RouteConfig } from '@hono/zod-openapi'

export type CreateOpenAPIHonoRouteOpts<
  TAuthenticated extends boolean = true,
  TMethod extends RouteConfig['method'] = RouteConfig['method']
> = Simplify<
  {
    authenticated: TAuthenticated
    paramsSchema?: AnyZodObject
    bodySchema?: AnyZodObject
    responseSchema: AnyZodObject
    method: TMethod
  } & SetRequired<
    Omit<
      SetOptional<Parameters<typeof createRoute>[0], 'responses'>,
      'request' | 'responses' | 'security'
    >,
    'path' | 'operationId' | 'tags' | 'description'
  >
>

export function createOpenAPIHonoRoute<TAuthenticated extends boolean>(
  opts: CreateOpenAPIHonoRouteOpts<TAuthenticated>
) {
  const {
    authenticated,
    paramsSchema,
    bodySchema,
    responseSchema,
    ...createRouteOpts
  } = opts

  return createRoute({
    ...createRouteOpts,
    security: authenticated
      ? [
          {
            bearerAuth: []
          }
        ]
      : [],
    request: {
      params: paramsSchema!,
      body: bodySchema
        ? {
            required: true,
            content: {
              'application/json': {
                schema: bodySchema
              }
            }
          }
        : undefined
    },
    responses: {
      200: {
        description: responseSchema.shape.description,
        content: {
          'application/json': {
            schema: responseSchema
          }
        }
      }
      // TODO
      // ...openApiErrorResponses
    }
  })
}
